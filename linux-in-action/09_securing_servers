-------------------------------------------------------
CHAPTER 9 - SECURING SERVERS
-------------------------------------------------------

- Low-Hanging Fruit

    - Always keep regular backups.


    - Apply all software updates regularly.  There is a risk that upgrading packages may
        cause issues, but it must be done anyway.  This risk can be mitigated by trying
        the updates in staging environments first.

        $ sudo apt update
        $ sudo apt upgrade

      Keep in mind that updating the package manager will only update packages installed 
        by it.  Any software that was installed separately will need to be manually
        updated.



- Using Firewalls

    - A 'firewall' is a set of rules.  When a data packets moves into or out of a protected
        network space, its contents (its origin, target, and protocol) are tested against
        the firewall rules to see if it should be allowed through.


    - For instance, for a web server, let's say it must be open to both HTTP and HTTPS 
        traffic from anywhere in the world.  Also, since admins and developers will need to
        log in from time to time, we must enable SSH only for the people who need it.  All
        other requests should be automatically refused.


    - A Linux machine can be configured to apply firewall rules at the kernel level using 
        the 'iptables' program.  It's not too complex, but to make it easier to configure,
        Linux distros now include higher-level tools that are easier to use like 'ufw' (Ubuntu)
        and 'firewalld' (CentOS).



- Installing and Configuring firewalld

    - 'firewalld' is part of the 'systemd' family of utilities.  It can be installed on 
        Debian-like machines as well as RedHat-like machines.  

        # Install firewalld
        $ sudo apt install firewalld


    - The 'firewall-cmd' tool is used to administer firewalld from the command line.

        # Check the current firewall status
        $ sudo firewall-cmd --state


    - By default, all incoming traffic except for SSH will be blocked.  We'll have to add
        exceptions for web traffic.

        # Add rules to open the HTTP and HTTPS ports
        $ sudo firewall-cmd --permanent --add-port=80/tcp
        $ sudo firewall-cmd --permanent --add-port=443/tcp

        # Reload to apply rules to current session
        $ sudo firewall-cmd

        # We can use standard service names instead of port numbers
        $ sudo firewall-cmd --permanent --add-service=http
        $ sudo firewall-cmd --permanent --add-service=https

        # List all current settings
        $ sudo firewall-cmd --list-services


    - We can also remove services.

        # Remove ssh access
        $ sudo firewall-cmd --permanent --remove-service=ssh
        $ sudo firewall-cmd --reload

        # Test the configuration, login should fail
        $ ssh root@192.168.1.22

        # Now, add a rule to re-enable ssh
        $ sudo firewall-cmd --add-rich-rule='rule family="ipv4" source address="192.168.1.5 \
            port protocol="tcp" port="22" accept'



- Installing and Configuring ufw

    - 'ufw' is often installed by default on Debian-like systems.

        # Install ufw
        $ sudo apt install ufw

        # Add rule to allow ssh
        $ sudo ufw allow ssh

        # Enable ufw
        $ sudo ufw enable


    - Now, we can create rules for HTTP and HTTPS traffic.

        # Add rules to allow HTTP and HTTPS
        $ sudo ufw allow 80
        $ sudo ufw allow 443

        # Get the list of active rules
        $ sudo ufw status


    - We can also fine tune the rules to only allow certain IP addresses.

        # Stop and disable firewall
        $ sudo ufw disable

        # Delete the 2nd firewall rule in the list
        $ sudo ufw delete 2

        # Allow ssh for a specific ip
        $ sudo ufw allow from 10.0.3.1 to any port 22

        # Re-enable the firewall
        $ sudo ufw enable

        # Get list of active rules
        $ sudo ufw status



- Using Nonstandard Ports

    - Some admins will use nonstandard ports to provide security through obscurity.  For
        instance, we can set the port used for SSH in the '/etc/ssh/sshd_conf' file on the
        server.

        # Default /etc/ssh/sshd_conf
        Port 22

        # We can change it
        Port 55555

        # Then, just restart the service
        $ sudo systemctl restart ssh

        # And, we'll have to open the port we want to use
        $ sudo ufw allow 55555/tcp


    - After this, we can specify the port we want to use when we ssh into the machine.

        $ ssh -p 55555 username@ip



- Network Ports

    - Ports 1-1023 are designated as 'well-known' and have been set aside for recognized
        services.  Using one of these ports is likely to cause a conflict.

      Examples:
        22 (SSH)
        80 (HTTP)


    - Ports 1024-49151 are 'registered', meaning that companies and organizations have 
        requested that specific ports be set aside for their applications.

      Examples:
        1812 (RADIUS)
        3306 (MySQL)


    - Ports 49152-65535 are 'unregistered' and are considered dynamic or private.  These
        ports are available for any temporary or ad hoc use.



- Encrypting Data in Transport

    - Any private information on websites must be encrpyted.  Even if the information is
        public, encrypting the site will cause it to generate more traffic, since Google's
        PageRank algorithm penalizes unencrypted websites.


    - To encrypt websites, we use 'certificates', which are files containing information 
        identifying the domain, owner, key, and a reliable digital signature.

      Once you have a certificate, browsers can authenticate the security of your site and
        exchange only encrypted data throughout a session.  All widely used modern browsers
        come with public root certificates preinstalled, so they can authenticate 
        connections with any site using a private CA certificate.


    - The steps in the process are:

        1. A client browser requests the server identity so the two can perform a handshake.

        2. The server responds by sending a copy of the certificate it received from a CA.

        3. The browser compares the certificate against its list of root certificates and 
             confirms that your certificate hasn't been expired or been revoked.

        4. If satisfied, the browser encrypts a symmetric session key using the public key
             your server sent, and transmits the key to the server.

        5. All transmissions will be encrypted using the session key.



- Certificate Authorities

    - Until 2016, generating and installing encryption certificates using the SSL/TLS
        standard took time and cost money.  

      On Linux, you would use the OpenSSL command line interface to generate a key pair and then 
        put together a specially formatted CSR (Certificate Signing Request) package containing 
        the public half of the pair along with site profile information.

      The CSR would then be sent to a CA.  If the CSR was approved, the CA would send a 
        certificate to be added to your file system.  And, you would update the Apache config
        files so that Apache would know where the cert was stored.


    - Since 2016, 'Let's Encrypt' has been issuing certificates as a CA for free.  It's sponsored
        by the Electronic Frontier Foundation and a bunch of corporate partners.

      We don't even need to worry about configuring files and using OpenSSL to generate CSRs any
        more.  Let’s Encrypt’s 'Certbot ACME' client will do pretty much the whole thing for you. 
        Let’s Encrypt certificates are valid for 90 days and can be set to automatically renew. 



- Generating Certificates

    - First, you'll need to acquire a domain name from a registrar like GoDaddy or AWS Route 53.
        For our example server, are domain is 'bootstrap-it.com'.

        # /etc/apache2/sites-available/000-default.conf
        <VirtualHost *:80>
            ServerName bootstrap-it.com
            DocumentRoot /var/www/html
            ServerAlias www.bootstrap-it.com
        </VirtualHost>


    - Next, we'll install the Certbot.

        # Add the certbot repo to our apt list
        $ sudo apt install software-properties-common
        $ sudo add-apt-repository ppa:certbot/certbot
        $ sudo apt update

        # Install certbot
        $ sudo apt install python-certbot-apache


    - Now, we can launch the certbot.  Certbot will read our web server config files to infer 
        the domain names we'll likely want to register.

        # Launch certbot
        $ sudo certbot --apache

        Which names would you like to activate HTTPS for?
        --------------------------
        1: bootstrap-it.com
        2: www.bootstrap-it.com
        --------------------------
        Select the appropriate numbers separated by commas and/or spaces,
          or leave input blank to select all options shown (Enter 'c' to cancel):


    - Once we have selected the domains, Certbot will try to confirm our domain exists in a
        publicly accessible DNS server.  Then, it will try to connect to your site.  

      If that is successful, a certificate will automatically be installed and any additional 
        information will be added to your config files.