-----------------------------------------------------------
CHAPTER 9 - COMMAND LINE PROGRAMMING
-----------------------------------------------------------

- Output to the Display

    - The 'echo' command prints data to the screen.  

        # Print home directory
        $ echo "My home directory." ; ls

        # The -e flag enables escape sequences
        $ echo "FirstLine.\nSecondLine"


    - The 'printf' command (print formatted) command allows more complex formatting.  The command
        can also use all the C printf specs, so there are a ton of built-in formatting options.

        # Escape sequences work
        $ printf "FirstLine.\nSecondLine"

        # Get details about C spces
        $ man 3 printf



- Variables

    - Variables are assigned without a $, but they are accessed with a $.

        # Set and print variable
        $ echo $MyVar ; MyVar="Hello World" ; echo $MyVar

        # Variables can be unset and returned to a null value
        $ unset MyVar

        # String variables can be combined in various ways
        $ Var1="Hello World!" ; Var2="Welcome to Bash CLI programming."
        $ printf "$Var1\n$Var2\n" ;


    - Bash can perform basic integer math:

        # Basic integer math
        $ Var1="7" ; Var2="9" ; echo "Result = $((Var1∗Var2))"
        Result = 63


- Control Operators

    - Return Codes

        - Every bash statement generates a return code.

            # Check return code of last command run with $? operator
            $ ll ; echo "RC = $"
            ...
            RC = 0


            # Nonzero return code means command was unsuccessful
            $ ll /root ; echo "RC = $?"
            ls: cannot open directory '/root': Permission denied
            RC = 2


    - The Operators

        - The ; operator allows multiple statements on a single line.  A semicolon on the last
            statement can beither implicit or explicit.


        - The && operator runs the second command only if the first is successful.

            # Create dirctory and file
            $ Dir=chapter9
            $ mkdir $Dir/subdirectory && touch $Dir/subdirectory/testfile


        - The || operator runs the second command only if the first is unsuccessful.

            # Handle unsuccessful command
            $ Dir=chapter9
            $ mkdir $Dir/subdirectory || echo "New file was not created."

            mkdir: cannot create directory ‘chapter9/subdirectory’: Permission denied
            New file was not created.


        - We can use && and || together to perform the sequence of statements we need to perform
            and handle errors.

            # Use && and || together
            $ Dir=chapter9
            $ mkdir $Dir/subdirectory && \
               touch $Dir/subdirectory/testfile || \
               echo "New file was not created."



- The if Statement

    - The syntax for the 'if' statement is:

        if condition1; then list1; [ elif condition2; then list2; ] ... [ else list3; ] fi



- true and false

    - The 'true' command always produces a return code of 0, and the 'false' command always
        produces a return code of 1.

        # Return code 0
        $ true ; echo $?
        0

        # Return code 1
        $ false ; echo $?
        1

        # 'true' with operators
        $ true && echo "True" || echo "False"
        True

        # 'false' with operators
        $ false && echo "True" || echo "False"
        False



- Logical Operators

    - The functional syntax of these comparison operators is 1 or 2 arguments with an 
        operator that are placed within square braces.  We have a 'list' of program
        statements that are executed if the statement is true, and an optional list
        of program stratements if the condition is false.

        # If only
        if [ arg1 operator arg2 ] ; then list

        # If/else
        if [ arg1 operator arg2 ] ; then list ; else list ; fi


    - The square braces are the traditional Bash symbols that are equivalent to the   
        'test' command.  

        # If only
        if test arg1 operator arg2 ; then list


    - There is also a more recent double square bracket syntax that has a few 
        advantages.

        # If only
        if [[ arg1 operator arg2 ]] ; then list



- File Operators

    Operators
    ----------------------------------------------------------------------------------------
    -a filename            True if file exists
    -b filename            True if file exists and is block special file (ie /dev/sda1)
    -c filename            True if file exists and is character special file (ie /dev/TTY1)
    -d filename            True if file exists and is a directory
    -e filename            True if file exists (same as -a)

    -f filename            True if file exists and is regular file
    -g filename            True if file exists and is set-group-id, SETGID
    -h filename            True if file exists and is symbolic link
    -k filename            True if file exists and its sticky bit is set
    -p filename            True if file exists and is a named pipe (FIFO)

    -r filename            True if file exists and is readable (has read bit set)
    -s filename            True if file exists and has size greater than zero
    -t fd                  True if file descriptor fd is open and refers to a terminal
    -u filename            True if files exists and its set-user-id bit is set
    -w filename            True if file exists and is writable
    -x filename            True if file exists and is executable

    -G filename            True if file exists and is owned by the effective group id
    -L filename            True if file exists and is a symbolic link
    -N filename            True if file exists and has been modified since it was last read
    -O filename            True if file exists and is owned by effective user id
    -S filename            True if file exists and is a socket

    file1 -ef file2        True if file1 and file2 refer to the same device and inode number
    file1 -nt file2        True if file1 is newer, or if file1 exists and file2 does not
    file1 -ot file2        True if file1 is older, or if file2 exists and file1 does not



- File Operator Examples

    - To check for the existence of a file:

        # Check whether a file exists
        $ File="cpuHog"
        $ if [ -e $File ] ; then echo "The file $File exists." ; fi

        # This does the same thing
        $ if [[ -e $File ]] ; then echo "The file $File exists." ; fi

        # This also does the same thing
        $ if test -e $File ; then echo "The file $File exists." ; fi


    - To also handle the case in which the file does not exist:

        # Print message whether file exists or not
        $ File="cpuHog"
        $ if [ -e $File ] ; then echo "The file $File exists." ; \
            else echo "The file $File does not exist." ; fi


    - To check whether a file exists and is nonempty:

        # Check if file is non-empty
        $ File="Exp-9-7"
        $ if [ -s $File ] ; then echo "$File exists and contains data." ; fi

    
    - We can add the 'elif' block to discriminate between a file that doesn't exist and one
        that is empty:

        # Check whether file exists and whether it is empty
        $ File="Exp-9-7" ; touch $File
        $ if [ -s $File ] ; then echo "$File exists and contains data." ; \
            elif [ -e $File ] ; then echo "$File exists and is empty." ; \
            else echo "$File does not exist." ; fi



- Example - Formatted Bash Script

    #!/bin/bash
    
    File='Exp-9-7'
    echo "This is $File" > $File
    if [ -s $File ]
       then
       echo "$File exists and contains data."
    elif [ -e $File ]
       then
       echo "$File exists and is empty."
    else
       echo "$File does not exist."
    fi



- String Comparison Operators

    Operators
    --------------------------
    -z string          True if length is zero
    -n string          True if length is non-zero

    str1 == str2       True if strings are equal
    or                   - Second form should be used with test command
    str1 = str2          - When used with [[ command, performs pattern matching

    str1 != str2       True if strings are not equal

    str1 < str2        True if str1 sorts before str2 lexicographically

    str1 > str2        True if str1 sorts after str2 lexicographically



- Numerical Comparison Operators

    Operators
    --------------------------
    arg1 -eq arg2      Equal
    arg1 -ne arg2      Not equal

    arg1 -lt arg2      Less than
    arg1 -le arg2      Lest than or equal to

    arg1 -gt arg2      Greater than
    arg1 -ge arg2      Greater than or equal to



- Miscellaneous Operators



- Grouping Program Statements


- Expansions

    - Brace Expansion
    - Tilde Expansion
    - Pathname Expansion
    - Command Substitution
    - Arithmetic Expansion


- for Loops


- Other Loops

    - while Loops
    - until