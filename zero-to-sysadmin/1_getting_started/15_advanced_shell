-----------------------------------------------------------
CHAPTER 15 - ADVANCED SHELL TOPICS
-----------------------------------------------------------

- The bash Shell

    - The bash shell, like any other shell, is a command-line interpreter.  It takes
        commands entered onto the command line, expands any file globs (like * and ?),
        converts the results into tokens for use by the kernel, then passes the
        resulting command to the kernel for execution.


    - bash is both a command interpreter and a programming language.  



- Shell Options

    - There are a wide varitey of shell options available, but the defaults rarely need to be
        changed.

        # List the current settings for shell options
        $ shopt



- Shell Variables

    - We use the $ operator to reference variables.  Note that bash does not allow spaces
        before or after the = assignment operator.

        # Print an existing variable
        $ echo $HOSTNAME

        # Create a variable and print it
        $ MYVAR="Hello World!"
        $ echo $MYVAR



- Commands

    - Commands fall into 2 categories:

        1. Internal Commands = commands that are an integral part of the shell

        2. External Commands = commands with a separate existence, which have their own
                                 executable files, like GNU and Linux core utilities


    - Internal commands are executed before an external command with the same name.  For
        instance, there is an internal 'echo' command and an external 'echo' command.  
        Unless you specify the path to an external command, the internal one will be used.


    - When a command is entered, this is how the bash shell works:

        1. Type the command and press Enter.

        2. Bash parses the command to see if a path is prepended to the command name.  If it
             is, go to Step 4.

        3. Bash checks to see if the command is internal.  If it is, bash runs the command
             immediately.

        4. If a path is used as part of the command, bash forks a new subprocess in which to
             execute the command and then runs the command.  This forking takes time as well
             as CPU, I/O, and RAM.

        5. If no path is specified, and this is not an internal command, bash searches the
             list of aliases and shell functions (system- and user-created procedures).  If
             one is found, it forks a new shell subprocess and executes the function or alias.

        6. If no alias or function is located, bash then searches the list of directories 
             specified in the $PATH shell variable.  When the command is located, bash forks
             a new subshell to execute the command.

        7. If a command is run in a subshell, the subshell terminates and execution is 
             returned to the parent shell.



- The PATH

    - The $PATH variable defines a colon-separated list of directories in which the 
        system and the shell look for executable files.  The shell looks in each directory
        listed in $PATH for executable files when a non-internal command is entered.

        # Display the default value of PATH
        $ echo $PATH

        /usr/local/bin:
        /usr/bin:
        /usr/local/sbin:
        /usr/sbin:
        /home/student/.local/bin:
        /home/student/bin


    - Looking more closely:

        /usr/local/bin
        --------------------
          Specifically defined location for storing locally created shell scripts such as
            shell scripts for SysAdmins or use by all users.

        /usr/local/etc
        --------------------
          Used for storing configuration files for the executables in /usr/local/bin.

        /usr/bin
        --------------------
          Most user-executable binary files go here.  It is intended for use by all users.

        /usr/sbin
        --------------------
          Same as /usr/bin, but for binaries that require superuser privileges.

        /usr/local/sbin
        --------------------
          Standard, but non-essential system binaries for use by the SysAdmin.

        /home/student/.local/bin
        --------------------
          A user's private executables which were locally created.

        /home/student/bin
        --------------------
          A user's private executables which were not locally created.



    - Note that our home folder is not in the path, which is why we have to precede our
        executable with the directory name.

        # Different ways to run an executable in our home directory
        $ ./cpuHog
        $ ~/cpuHog
        $ /home/student/cpuHog



- Internal Commands

    - The bash shell has a large number of built-in internal commands.

        # Get list of built-in commands
        $ help

        # Get help for a single built-in command
        $ help echo

        # Note that help pages are for internals, while man pages are for externals
        $ man Bash


    - The 'type' command lets us identify which commands are built-in.

        # Get types of commands
        $ type echo getopts egrep

        echo is a shell builtin
        getopts is a shell builtin
        egrep is aliased to `egrep --color=auto'



- External Commands

    - External commands are those that exist as executable files and which are not part
        of the shell.  The executable files are stored in locations like /bin, /usr/bin,
        /sbin, and so on.

        # Look at files in /bin and locate some familiar commands
        $ cd /bin
        $ ll

        # Get types of commands and the locations of their executables with -a option
        $ type -a echo getopts egrep

        echo is a shell builtin
        echo is /usr/bin/echo
        getopts is a shell builtin
        getopts is /usr/bin/getopts
        egrep is aliased to `egrep --color=auto'
        egrep is /usr/bin/egrep



- Compound Commands

    - The simplest form of compound command is to just string together multiple commands
        on a single line:

        $ command1 ; command2 ; command3 ; command4 ; command5


    - We can anticipate the possibility of errors by using the && and || operators:

        # If command1 is successful (0 return code), then run command2
        $ command1 && command2

        # If command1 fails (nonzero return code), then run command2
        $ command1 || command2


    - The && and || operators work since every command sends a return code (RC) to the 
        shell that indicates whether it was successful or not.  By convention, a return
        code of 0 indicates success, while any positive number indicates some type of
        failure.  The bash shell uses the '$?' variable to store the RC of the last
        operation.

        # Successful command
        $ ll ; echo "RC = $?"
        RC = 0

        # Unsuccessful command
        $ ll /root ; echo "RC = $?"
        ls: cannot open directory '/root': Permission denied
        RC = 2


    - Examples of && and || operators:

        # If successful
        $ mkdir ~/testdir/testdir9 && touch ~/testdir/testdir9/testfile1

        # If unsuccessful
        $ mkdir ~/testdir/testdir9 || echo "testdir9 was not created."



- Brace Expansion


- Special Characters (File Globbing)


- Sets


- Meta-Characters


- Using grep


- Finding Files