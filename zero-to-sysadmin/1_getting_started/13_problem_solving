-----------------------------------------------------------
CHAPTER 13 - TOOLS FOR PROBLEM SOLVING
-----------------------------------------------------------

- The 5 Steps of Problem Solving

    1. Knowledge
    2. Observation
    3. Deduction
    4. Action
    5. Test



- System Performance and Problem Solving with top

    - There are a large number of Linux commands that are used in the process of analyzing
        system performance and problem determination.  Most of these commands obtain their
        information from various files in the /proc filesystem.


    - The 'nice' command can be used to change the nice number (renice) of a process in 
        order to modify its priority level.


    - The 'top' command has been around for a very long time and is nearly always present
        in Linux installations.  It observes memory and CPU usage as well as load averages
        in a dynamic setting.  It is the first tool used to troubleshoot many problems.

        $ top

        top - 21:48:21 up 7 days,  8:50,  7 users,  load average: 0.00, 0.00, 0.00
        Tasks: 195 total,   1 running, 136 sleeping,   0 stopped,   0 zombie
        %Cpu(s):  0.0 us,  0.2 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.2 si,  0.0 st
        KiB Mem :  4038488 total,  2369772 free,   562972 used,  1105744 buff/cache
        KiB Swap: 10485756 total, 10485756 free,        0 used.  3207808 avail Mem
          PID USER     PR  NI    VIRT   RES   SHR S  %CPU %MEM     TIME+ COMMAND
         5173 student  20   0  316084  3328  2884 S   0.3  0.1   5:16.42 VBoxClient
         7396 root     20   0  257356  4504  3620 R   0.3  0.1   0:00.03 top
            1 root     20   0  237000  9820  6764 S   0.0  0.2   0:23.54 systemd
            2 root     20   0       0     0     0 S   0.0  0.0   0:00.26 kthreadd
            3 root      0 -20       0     0     0 I   0.0  0.0   0:00.00 rcu_gp
            4 root      0 -20       0     0     0 I   0.0  0.0   0:00.00 rcu_par_gp
            6 root      0 -20       0     0     0 I   0.0  0.0   0:00.00 kworker/0:0H-kb
            8 root      0 -20       0     0     0 I   0.0  0.0   0:00.00 mm_percpu_wq
            9 root     20   0       0     0     0 S   0.0  0.0   0:01.40 ksoftirqd/0
           10 root     20   0       0     0     0 I   0.0  0.0   0:10.44 rcu_sched
           11 root     20   0       0     0     0 I   0.0  0.0   0:00.00 rcu_bh


    - We can press 's', then '1' to change the update interval from 3s to 1s.  
      Then, we press '1' to toggle from aggregate CPU to each CPU on a separate line.
      Finally, we press 'W' to save the changes we made.


    - We can press 'h' for help, then press 'h' again to go to the other help screen.
      Then, we press 'q' to go back to the active display.



- top Summary Section

    top - 21:48:21 up 7 days,  8:50,  7 users,  load average: 0.00, 0.00, 0.00

    
    - Load averages are 1-minute, 5-minute, and 15-minute averages.  

      The load average is a measure of demand for the CPU.  It is the average number of 
        instructions waiting for CPU time.  Thus, in a single processor system, a fully 
        utilized CPU would lave a load average of 1.

      If the load average is <1, the CPU is underutilized.
      If the load average is >1, there is pent-up demand.

    
    - If a 4-CPU system has a load average of 4, there is perfect utilization.  If it
        is <4, the CPUs are underutilized.  If the load average is >4, there is pent-up
        demand.



- top CPU Usage

    - The CPU usage is a fairly simple measure of how much CPU time is being used executing
        instructions.  They are displayed as percentages and represent the amount of time a 
        CPU is being used during the defined time period.

        Cpu0   :  0.0%us,  0.0%sy,  0.0%ni,  100.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st

        us = % of time spent performing tasks in user space
        sy = % of time spent performing system (kernel) tasks
        ni = % of time spent on tasks that have a positive nice number
        id = % of idle time CPU is free or waiting for I/O
        wa = % of time waiting on I/O
        hi = % of time waiting on hardware interrupts
        si = % of time waiting for software interrupts (high number could indicate race condition)
        st = % of time stolen from VM by another VM due to hypervisor allocation



- top Process Section

    PID  USER     PR  NI    VIRT   RES   SHR S  %CPU %MEM     TIME+ COMMAND
    5173 student  20   0  316084  3328  2884 S   0.3  0.1   5:16.42 VBoxClient
    7396 root     20   0  257356  4504  3620 R   0.3  0.1   0:00.03 top

        PID      = process ID
        USER     = username of the process owner
        PR       = priority of the process
        NI       = nice number of the process
        VIRT     = amount of virtual memory allocated to the process
        RES      = resident size of physical RAM consumed by the process (in KB)
        SHR      = amount of shared memory used by the process (in KB)
        S        = status of the process
                     R = running
                     I = idle
                     S = sleeping
                     Z = zombie
                     T = traced or stopped
                     D = deep, uninterruptable sleep
        %CPU     = % of CPU cycles used by this process
        %MEM     = % of physical RAM used by the process
        TIME+    = cumulated CPU time consumed by process since start
        COMMAND  = command used to launch the process


    - The 'PageUp' and 'PageDown' keys can be used to page through the process list.
      The 'k' key can be used to kill a process, and 'r' can be used to renice it.



- Experiment - Observing a CPU Hog

    - First, we'll create a program that is a CPU hog.

        # Create the script file
        $ touch cpuHog
        $ chmod 755 cpuHog

        # Here is the script
        #!/bin/bash
        # This little program is a cpu hog
        X=0;while [ 1 ];do echo $X;X=$((X+1));done

        # Now, run the script
        $ ./cpuHog


    - Then, we can create another instance of the cpuHog program.  We'll see that they
        use nearly the same amount of CPU while they are running.

      If we then change the nice number for one of the processes from +20 to -19, it will
        have a higher priority and will eventually accumulate more CPU time.



- top Memory Statistics

    KiB Mem :  4038488 total,  2369772 free,   562972 used,  1105744 buff/cache
    KiB Swap: 10485756 total, 10485756 free,        0 used.  3207808 avail Mem

    - The total memory, free, used, and swap are shown.


    - The 'buff/cache' is RAM, but not swap space, that is used for temporary storage.  
        Buffers are typically a designated area of memory where the OS will store data 
        that is being transmitted over the network, a serial communication line, or
        to another program.  The data is stored for a short period of time until the program
        or utility using that data can catch up and process it.

      Data in the buffer is not altered until it is removed and used.  Buffers enable 
        processes that may work at different speeds to communicate without data loss.


    - Linux provides a tool called a named pipe that works as a storage buffer between 
        2 or more programs.  Named pipes can provide inter-process communication between
        scripts and other executable programs, as well as a place to store output data for
        later used by other programs.  They are FIFO data structures.


    - Cache is RAM memory that is allocated especially to data that may be changing and 
        may be used in the near future.  Buffers and cache are similar in that they are 
        both allocated in RAM and used for temporary storage.  The difference is the manner
        in which they are used.



- Experiment - Named Pipes

    - We'll need 2 termial sessions for this experiment.  In the first terminal, create a 
        named pipe.  

        # Create a named pipe called 'mypipe' in home directory
        $ mkfifo mypipe

        # Now look at contents of home directory
        $ ll

        ...
        prw-rw-r--  1 student student     0 Oct 25 21:21 mypipe
        ...


        # Now, we can put a list of the disk drives into the pipe
        $ lsblk -i > mypipe


    - Now, in the other terminal, well use the cat command to read from the pipe.

        # Read from named pipe
        $ cat mypipe

      Once all the data from the pipe is sent to STDOUT, both terminals should return to
        the command prompt.



- top Signals

    - The top, atop, and htop utilities allow you to send signals to running processes.  Each
        of these signals has a specific function.


    - The 'kill' command can also be used to send signals to processes.  

        SIGTERM (15)
          Tells the program to terminate itself, can be intercepted of the program has a
            signal handler

        SIGKILL (9)
          Terminates program without waiting for cleanup, will kill both the program and the
            shell in which it is running (if any), cannot be intercepted by a signal handler.

        SIGINT (2)
          Sends an interrupt to the running program, similar to pressing Cntl+C in a shell.



- Other top-like Tools

    - Here are tools we need to install:

        $ dnf -y install htop atop iotop


    - htop

        The htop utility is like top, but it allows selection of multiple running processes
          so they can be acted on simultaneously.  It allows you to kill, renice, or send
          signals to one or more processes simultaneously.  

        $ htop

        Commands:
          space   = Select a process in the list
          F1      = Help  
          F2      = Setup  
          F3      = Search 
          F4      = Filter 
          F5      = Tree  
          F6      = SortBy 
          F7      = Nice - 
          F8      = Nice + 
          F9      = Kill  
          F10     = Quit


    - atop

        The atop utility is also like top, but it also displays detailed information on I/O
          usage including aggregated, per device, and per process data.

        $ atop



- Memory Tools


- Tools That Display Disk I/O Statistics


- The /proc Filesystem


- Exploring Hardware


- Monitoring Hardware Temperatures


- Monitoring Hard Drives


- System Statistics with SAR

    - Installation and Configuration
    - Examining Collected Data
    - 


- Cleanup